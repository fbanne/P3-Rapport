To make sure the program works the way it is intended to work, it is important to figure out if the programs methods and algorithm works as intended. There exist two basics of software testing which can be applied: Blackbox Testing and Whitebox Testing. Blackbox Testing is a testing technique which ignores the internal mechanism of the program and only focuses on the output that is generated by some sort of input and execution of the system. Whitebox Testing is a testing technique which takes account into the internal mechanism of a system, unlike Blackbox Testing.

From these two forms of testing there are many types of testing. For example, unit testing which is testing of an individual group or unit of related units, and is a form of Whitebox Testing. Unit testing is usually used to test certain methods and functions with output, and validate whether or it returns what is expected, with various ranges of input. \cite{Testing}

We decided to use Unit Testing on the program, since the system relies on that the controller methods creates correctly made classes and data validation. For example with vector updating and login handling. Besides that, it was also very easy to test with Visual Studios, since Visual Studios has a build in function, that makes it possible to test every method you wish to test, though it can not test private and protected methods, since it is bound by general C\# access modifiers.

For example this is a code block of one of the many methods we have tested.

\begin{lstlisting}[caption={A unit test which tests the associated person controller},label={UnitTestOne}]
[TestMethod]
public void Associated_People_Controller_Determine_Person()
{
	AssociatedPeopleController apc = new AssociatedPeopleController();
	Assert.IsTrue(apc.CreateAssociatedPerson<Director>("test director") is Director);
	Assert.IsTrue(apc.CreateAssociatedPerson<Actor>("test actor") is Actor);
}
\end{lstlisting}

In Listing \ref{UnitTestOne} we check for, with help from the User Test function Assert if we get the correct output from the given input. Another similar test checks whether or not the same ID was generated was generated thought associated person controller, when they have the same name, but different class derivations.

Another example from within the testing class
\begin{lstlisting}[caption={A unit test which tests the login controller},label={UnitTestTwo}]
[TestMethod] 
public void Login_Controller()
{
	string userName = "boge";
	string password = "123456";

	UserCollection.Instance.Add(new User(userName, password, DateTime.Now, Sex.Female, new List<int>()));

	LoginController LC = new LoginController();

	Assert.IsTrue(LC.Login(userName, password));
	Assert.IsFalse(LC.Login("IDoNotExist", "123456"));
	Assert.IsFalse(LC.Login(userName, "ThisIsNotMyPassword"));
}
\end{lstlisting}


In Listing \ref{UnitTestTwo} we test if the login method behave as they should do. It is tested if the users username and password behaves as it should do, when inserted as input into the login method as input. First of all the test checks if the username and password matches the test user which were made, and should return a true boolean. Next the test checks for if the username is not present in the collection of users, and returns a false boolean. Thirdly it is checked if the password is not a possible input, and doesn’t match the test user which is retrieved with the username input. This assertion should also evaluate to a false boolean. Currently, the two examples shown here and all other unit tests shows the controller methods performs as they’re expected to. The most crucial methods was tested, which is those the controllers contains. Many of the outward public methods in the controllers have several private methods, which cannot be directly tested because of access modifiers. They’re instead tested indirectly through the public methods in the controller, which is dependent on the private methods performs as they should.

One form of testing we also would have liked to test is the Beta Testing, which is done by users, and not the developers of the system. These testers can try the program and find unexpected bugs by using it, and see if the systems features and recommendations algorithm works as they should, and whether or not correct recommendations is generated. This is Blackbox testing. Though we did not manage to get beta testing done, because we ran out of time, and it wasn’t possible to acquire a server so the beta testers could access the system. This is unfortunate, because it would had been appropriate to get actual users to test the program, since there are probably some unexpected errors we have not thought about and perhaps haven’t been catched by the unit tests.

The algorithm of the system could also have been much more thoroughly tested if a beta test had been done. Currently, testing on the algorithm have been done by simply using it among the participants of the project, and with media data collected through API’s and randomly generates test users. The content-based part of the algorithm could have used this added depth, but especially the collaborative part could have greatly benefited from having more natural data to work with. The content-based part works as intended, and returns for the most part recommendations which makes sense, since it has real data to work with. Since all users is random, and all media and given ratings in their medialists is random, the result of the collaborative part is also random. More natural testing through beta testing could have shown whether or not the collaborative algorithm returns good recommendations.
