To make sure the program works the way it is intended to work, it is important to figure out if the programs methods and algorithm works as intended. There exist two basics of software testing which can be applied; Blackbox Testing and Whitebox Testing. Blackbox Testing is a testing technique which ignores the internal mechanism of the program and only focuses on the output that is generated by some sort of input and execution of the system. Whitebox Testing is a testing technique which takes account fir the internal mechanism of a system, unlike Blackbox Testing.

From each of these two forms of testing there are many types of testing. For example, unit testing which is testing of an individual group or unit of related units, and is a form of Whitebox Testing. Unit testing is usually used to test certain methods and functions with output, and validate whether or not it returns what is expected, with various ranges of input. \cite{Testing}

We decided to use Unit Testing on the program, since the system relies on that the controller methods creates correctly made classes and data validation. It was also easy to test with Visual Studio, since it has a build in feature, that makes it possible to test every method you wish to test. Unfortunately, it cannot test private and protected methods, since it is bound by general C\# access modifiers.

\begin{lstlisting}[caption={A unit test which tests the associated person controller},label={UnitTestOne}]
[TestMethod]
public void Associated_People_Controller_Determine_Person()
{
	AssociatedPeopleController apc = new AssociatedPeopleController();
	Assert.IsTrue(apc.CreateAssociatedPerson<Director>("test director") is Director);
	Assert.IsTrue(apc.CreateAssociatedPerson<Actor>("test actor") is Actor);
}
\end{lstlisting}

In Listing \ref{UnitTestOne} you can see the associated person controller test, which uses assert statements to determine if the correct output is returned from the given input. Another similar test checks whether or not the same ID was generated with the associated person controller, when they have the same name, but different class derivations.

\begin{lstlisting}[caption={A unit test which tests the login controller},label={UnitTestTwo}]
[TestMethod] 
public void Login_Controller()
{
	string userName = "boge";
	string password = "123456";

	UserCollection.Instance.Add(new User(userName, password, DateTime.Now, Sex.Female, new List<int>()));

	LoginController LC = new LoginController();

	Assert.IsTrue(LC.Login(userName, password));
	Assert.IsFalse(LC.Login("IDoNotExist", "123456"));
	Assert.IsFalse(LC.Login(userName, "ThisIsNotMyPassword"));
}
\end{lstlisting}


In Listing \ref{UnitTestTwo} we test if the login method behave as it should do. The method is tested using various inputs for the username and password parameters. First of all the test checks if the username and password matches the test user which were made, and should return a true boolean. Next the test checks for if the username is not present in the collection of users, and returns a false boolean. Last it is checked if the password is not a possible input, and does not match the test user which is retrieved with the username input. This assertion should also evaluate to a false boolean. Currently, the two examples shown here and all other unit tests shows the controller methods performs as they are expected to. The most crucial methods was tested, which is those the controllers contains. Many of the outward public methods in the controllers have several private methods, which cannot be directly tested because of access modifiers. They are instead tested indirectly through the public methods in the controller, which is dependent on that the private methods performs as they should.

Beta testing is another form of testing that could have been used, which is done by users, and not the developers of the system. These testers can try the program and find unexpected bugs by using it, and see if the systems features and recommendation algorithm works as they should, and whether or not correct recommendation is generated. This is Blackbox testing. We did not manage to get beta testing done since it was not possible to acquire a server so the beta testers could access the system. This is unfortunate, because it would had been appropriate to get actual users to test the program, since there are probably some unexpected errors we have not thought about and perhaps have not been catched by the unit tests.

The algorithm of the system could also have been much more thoroughly tested if a beta test had been done. Currently, testing on the algorithm have been done by simply using it among the participants of the project, and with media data collected through APIâ€™s and randomly generate test users. The content-based part of the algorithm could have used beta testing, but especially the collaborative part could have greatly benefited from having more natural data to work with. The content-based part works as intended, and returns for the most part recommendations which makes sense, since it has real data to work with. Since all users is random, and all media and given ratings in their medialists is random, the result of the collaborative part is also random. More natural testing through beta testing could also show whether or not the collaborative algorithm returns good recommendations.